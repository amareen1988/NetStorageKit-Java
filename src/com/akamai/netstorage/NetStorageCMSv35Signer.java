/*
 * Copyright 2014 Akamai Technologies http://developer.akamai.com.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.akamai.netstorage;

import com.akamai.netstorage.Utils.KeyedHashAlgorithm;

import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.InetSocketAddress;
import java.net.Proxy;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;

/**
 * The NetStorageCMSv35Signer is responsible for brokering the communication between the software layer and the API. This
 * includes the signing and formatting the request appropriately so that the implementation detail is abstracted from
 * calling libraries. The intended calling library is the NetStorage class, but this layer can be called directly and is
 * offered as a convenience interface for enhanced implementations.
 * <p/>
 * TODO: support rebinding on IO communication errors (eg: connection reset)
 * TODO: support async IO
 * TODO: support multiplexing of uploads
 * TODO: optimize and adapt throughput based on connection latency
 * TODO: support HTTP trailers for late SHA256 validation
 *
 * @author colinb@akamai.com (Colin Bendell)
 */
public class NetStorageCMSv35Signer {

	protected static final String KITVERSION = "Java/3.52";
	protected static final String KITVERSION_HEADER = "X-Akamai-NSKit";

	//Main headers used for communication to the API
	protected static final String ACTION_HEADER = "X-Akamai-ACS-Action";
	protected static final String AUTH_DATA_HEADER = "X-Akamai-ACS-Auth-Data";
	protected static final String AUTH_SIGN_HEADER = "X-Akamai-ACS-Auth-Sign";

	public NetStorageCMSv35Signer(String method, URL url, String username, String key, APIEventBean params,
			InputStream uploadStream, long uploadSize, String proxyHostname, Integer proxyPort) {
		this(method, url, username, key, params, uploadStream, uploadSize);
		this.proxyHostname = proxyHostname;
		this.proxyPort = proxyPort;
	}

	/**
	 * There are multiple types of Net Storage. The following types are
	 * detected:
	 * - FileStore (also known as Net Storage 3).
	 * - ObjectStore (also known as Net Storage 4).
	 */
	public enum NetStorageType {
		FileStore,
		ObjectStore,
		Unknown;
	}

	/**
	 * Currently only 3 signing hash types are supported. Each are indicated with a version. They are:
	 * Hmac-MD5 = v3
	 * Hmac-SHA1 = v4
	 * Hmac-SHA256 = v5
	 * <p/>
	 * (don't ask what v1 and v2 were. You don't want to know. It will make you cry.)
	 */
	public enum SignType {
		HMACMD5(KeyedHashAlgorithm.HMACMD5, 3),
		HMACSHA1(KeyedHashAlgorithm.HMACSHA1, 4),
		HMACSHA256(KeyedHashAlgorithm.HMACSHA256, 5);
		private final int value;
		private final KeyedHashAlgorithm algorithm;

		private SignType(KeyedHashAlgorithm algorithm, int value) {
			this.value = value;
			this.algorithm = algorithm;
		}

		public int getValue() {
			return this.value;
		}

		public KeyedHashAlgorithm getAlgorithm() {
			return this.algorithm;
		}
	}

	/**
	 * Primary invocation for an API communication. This constructor is used for convenience when not uploading content
	 *
	 * @param method   an HTTP verb (GET, POST, PUT)
	 * @param url      the url to interact with (eg: http://example.akamaihd.net/254462 )
	 * @param username provisioned username from the Luna portal
	 * @param key      the associated key generated by the portal
	 * @param params   the set of bean parameters to be sent in the API request
	 */
	public NetStorageCMSv35Signer(String method, URL url, String username, String key, APIEventBean params) {
		this(method, url, username, key, params, null, -1L);
	}

	/**
	 * Primary invocation for an API communication. This constructor is used when uploading content is likely
	 * <p/>
	 * Generally, we don't expose that there are other sign versions available and assume it will be HMac-SHA256. However,
	 * this can be overriden in the setSignVersion() method;
	 *
	 * @param method       an HTTP verb (GET, POST, PUT)
	 * @param url          the url to interact with (eg: http://example.akamaihd.net/254462 )
	 * @param username     provisioned username from the Luna portal
	 * @param key          the associated key generated by the portal
	 * @param params       the set of bean parameters to be sent in the API request
	 * @param uploadStream the inputStream to read the bytes to upload
	 * @param uploadSize   if available, the total size of the inputStream. Note, that this could be different than the Size parameter in the action line
	 */
	public NetStorageCMSv35Signer(String method, URL url, String username, String key, APIEventBean params,
			InputStream uploadStream, long uploadSize) {
		this.setMethod(method);
		this.setUrl(url);
		this.setUsername(username);
		this.setKey(key);
		this.setParams(params);
		this.setUploadStream(uploadStream);
		this.setUploadSize(uploadSize);
		this.setSignVersion(SignType.HMACSHA256);
	}

	private String method;
	private URL url;
	private String username;
	private String key;
	private APIEventBean params;
	private InputStream uploadStream = null;
	private long uploadSize;
	private SignType signVersion = null;
	private String proxyHostname = null;
	private Integer proxyPort = null;

	public Integer getProxyPort() {
		return ((proxyPort != null) ? proxyPort : 8080);
	}

	public NetStorageCMSv35Signer setProxyPort(Integer proxyPort) {
		this.proxyPort = proxyPort;
		return this;
	}

	public String getProxyHostname() {
		return proxyHostname;
	}

	public NetStorageCMSv35Signer setProxyHostname(String proxyHostname) {
		this.proxyHostname = proxyHostname;
		return this;
	}

	public String getMethod() {
		return method;
	}

	public void setMethod(String method) {
		this.method = method;
	}

	public URL getUrl() {
		return url;
	}

	public void setUrl(URL url) {
		this.url = url;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getKey() {
		return key;
	}

	public void setKey(String key) {
		this.key = key;
	}

	public APIEventBean getParams() {
		return params;
	}

	public void setParams(APIEventBean params) {
		this.params = params;
	}

	public InputStream getUploadStream() {
		return uploadStream;
	}

	public void setUploadStream(InputStream uploadStream) {
		this.uploadStream = uploadStream;
	}

	public long getUploadSize() {
		return uploadSize;
	}

	public void setUploadSize(long uploadSize) {
		this.uploadSize = uploadSize;
	}

	public SignType getSignVersion() {
		return signVersion;
	}

	public void setSignVersion(SignType signVersion) {
		this.signVersion = signVersion;
	}

	/**
	 * Computes the value for the the X-Akamai-ACS-Action: header. This is a url query-string encoded separated
	 * list of parameters in the form of name=value&name2=value2. For extensibility purposes, we use generic method
	 * to convert the bean fields & parameters into name-value pairs and encode appropriately
	 *
	 * @return a url encoded query string of name-value pairs from the {@link com.akamai.netstorage.APIEventBean}
	 */
	protected String getActionHeaderValue() {
		return Utils.convertMapAsQueryParams(this.getParams().asQueryParams());
	}

	/**
	 * Constructs the X-Akamai-ACS-Auth-Data header which contains the signing version, the current time, a random number
	 * and the username that is used to sign the data.
	 *
	 * @return the data field in a comma separated list
	 */
	protected String getAuthDataHeaderValue() {
		Date currentTime = new Date();
		int rand = new Random().nextInt(Integer.MAX_VALUE);

		return String
				.format("%d, 0.0.0.0, 0.0.0.0, %d, %d, %s", this.getSignVersion().getValue(), currentTime.getTime() / 1000, rand,
						this.getUsername());
	}

	/**
	 * Computes the X-Akamai-ACS-Auth-Sign header for a given Action and Data header values. This results in a base64
	 * encoded representation of the hash as required by the spec. The api server will compute this same hash to validate
	 * the request
	 *
	 * @param action   action header values {@link #getActionHeaderValue()}
	 * @param authData data header values {@link #getAuthDataHeaderValue()}
	 * @return a base64 encoded return string
	 */
	protected String getAuthSignHeaderValue(String action, String authData) {
		String signData = String
				.format("%s%s\n%s:%s\n", authData, this.getUrl().getPath(), NetStorageCMSv35Signer.ACTION_HEADER.toLowerCase(),
						action);
		byte[] hash = Utils
				.computeKeyedHash(signData.getBytes(StandardCharsets.UTF_8), this.getKey(), this.getSignVersion().getAlgorithm());

		return Utils.encodeBase64(hash);
	}

	/**
	 * Assmembles the HTTP Headers necessary for API communication
	 *
	 * @return Map of name-value pairs representing HTTP Headers and values.
	 */
	public Map<String, String> computeHeaders() {
		final Map<String, String> headers = new HashMap<>(3);
		final String action = getActionHeaderValue();
		final String authData = getAuthDataHeaderValue();
		final String authSign = getAuthSignHeaderValue(action, authData);

		headers.put(NetStorageCMSv35Signer.KITVERSION_HEADER, NetStorageCMSv35Signer.KITVERSION);
		headers.put(NetStorageCMSv35Signer.ACTION_HEADER, action);
		headers.put(NetStorageCMSv35Signer.AUTH_DATA_HEADER, authData);
		headers.put(NetStorageCMSv35Signer.AUTH_SIGN_HEADER, authSign);
		return headers;
	}

	/**
	 * Attempt to validate the response and detect common causes of errors. The most common being time drift.
	 * <p/>
	 * TODO: catch rate limitting errors. Should delay and retry.
	 *
	 * @param connection
	 * @return true if 200 OK response, false otherwise.
	 * @throws NetStorageException wrapped exception if it is a recoverable exception
	 * @throws IOException         shouldn't be called at this point, but could be triggered when interrogating the response
	 */
	public boolean validate(HttpURLConnection connection) throws NetStorageException, IOException {
		if (connection.getResponseCode() == HttpURLConnection.HTTP_OK)
			return true;

		// Validate Server-Time drift
		Date currentDate = new Date();
		long responseDate = connection.getHeaderFieldDate("Date", 0);
		if (responseDate != 0 && currentDate.getTime() - responseDate > 30 * 1000)
			throw new NetStorageException("Local server Date is more than 30s out of sync with Remote server");

		// generic response
		throw new NetStorageException(String.format("Unexpected Response from Server: %d %s\n%s", connection.getResponseCode(),
				connection.getResponseMessage(), connection.getHeaderFields()), connection.getResponseCode());
	}

	/**
	 * Detect the type of Net Storage.
	 *
	 * @return The type of Net Storage.
	 * @throws NetStorageException if an error occurred during the communication.
	 */
	public NetStorageType getNetStorageType() throws NetStorageException {
		HttpURLConnection request = null;
		NetStorageType netNetStorage = NetStorageType.Unknown;
		try {
			request = (HttpURLConnection) this.getUrl().openConnection();
			request.setConnectTimeout(10000);
			request.setReadTimeout(10000);
			String auth = getAuthDataHeaderValue();
			String action = "action=stat";
			request.setRequestProperty(NetStorageCMSv35Signer.KITVERSION_HEADER, NetStorageCMSv35Signer.KITVERSION);
			request.setRequestProperty(NetStorageCMSv35Signer.AUTH_DATA_HEADER, auth);
			request.setRequestProperty(NetStorageCMSv35Signer.AUTH_SIGN_HEADER, getAuthSignHeaderValue(action, auth));
			request.setRequestProperty(NetStorageCMSv35Signer.ACTION_HEADER, action);
			request.connect();
			switch (request.getHeaderField("Server")) {
			case "AkamaiNetStorage":
				netNetStorage = NetStorageType.ObjectStore;
				break;
			case "Apache":
				netNetStorage = NetStorageType.FileStore;
				break;
			}
		} catch (IOException e) {
			if (request != null) {
				request.disconnect();
			}
			throw new NetStorageException("Communication Error", e);
		}
		return netNetStorage;
	}

	/**
	 * Opens the connection to Netstorage, assembles the signing headers and uploads any files.
	 *
	 * @return the InputStream from the response if successful
	 * @throws NetStorageException if an error occurred during the communication
	 */
	public InputStream execute() throws NetStorageException {
		HttpURLConnection request = null;
		try {
			if (this.getProxyHostname() != null && !this.getProxyHostname().isEmpty()) {
				InetSocketAddress proxyInet = new InetSocketAddress(this.getProxyHostname(), this.getProxyPort());
				Proxy proxy = new Proxy(Proxy.Type.HTTP, proxyInet);
				request = (HttpURLConnection) this.getUrl().openConnection(proxy);
			} else {
				request = (HttpURLConnection) this.getUrl().openConnection();
			}
			request.setRequestMethod(this.getMethod());
			request.setConnectTimeout(10000);
			request.setReadTimeout(10000);

			for (Map.Entry<String, String> entry : this.computeHeaders().entrySet())
				request.setRequestProperty(entry.getKey(), entry.getValue());

			if (this.getMethod().equals("PUT") || this.getMethod().equals("POST")) {
				request.setDoOutput(true);
				if (this.getUploadStream() == null) {
					request.setFixedLengthStreamingMode(0);
					request.connect();
				} else {
					byte[] buffer = new byte[1024 * 1024];

					if (this.getUploadSize() > 0)
						request.setFixedLengthStreamingMode(this.getUploadSize());
					else
						request.setChunkedStreamingMode(buffer.length);

					request.connect();

					try (BufferedInputStream input = new BufferedInputStream(this.getUploadStream())) {
						try (OutputStream output = request.getOutputStream()) {
							for (int length; (length = input.read(buffer)) > 0; ) {
								output.write(buffer, 0, length);
							}
							output.flush();
						}
					}
				}
			} else {
				request.connect();
			}

			validate(request);

			return request.getInputStream();

		} catch (NetStorageException | IOException e) {
			if (request != null) {
				try (InputStream is = request.getInputStream()) {
				} catch (IOException ioException) {
				}
				try (InputStream is = request.getErrorStream()) {
				} catch (IOException ioException) {
				}
			}
			throw new NetStorageException("Communication Error", e);
		}
	}
}
